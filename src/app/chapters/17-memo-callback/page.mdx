# useMemo & useCallback in the Age of the React Compiler

`useMemo` caches computed values. `useCallback` caches functions. Both exist to optimize performance—but the React Compiler is changing when you need them. This chapter covers how they work, when they help, and what the future holds.

## Learning Outcomes

After reading this chapter, you will:

- Understand how useMemo and useCallback work
- Know when memoization actually helps performance
- Avoid premature optimization
- Understand what the React Compiler automates
- Write code that works well with or without the compiler

---

## useMemo: Caching Computed Values

`useMemo` caches the result of a calculation:

```tsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

- First render: Runs the function, caches the result
- Subsequent renders: Returns cached result if dependencies unchanged
- If dependencies change: Recomputes and caches new result

```tsx
function ProductList({ products, filter }: Props) {
  // Only recomputes when products or filter changes
  const filteredProducts = useMemo(
    () => products.filter(p => p.category === filter),
    [products, filter]
  );

  return <List items={filteredProducts} />;
}
```

---

## useCallback: Caching Functions

`useCallback` caches a function definition:

```tsx
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b]
);
```

It's equivalent to:

```tsx
const memoizedCallback = useMemo(
  () => () => doSomething(a, b),
  [a, b]
);
```

```tsx
function SearchForm({ onSearch }: Props) {
  const [query, setQuery] = useState('');

  // Same function reference unless query changes
  const handleSubmit = useCallback(() => {
    onSearch(query);
  }, [query, onSearch]);

  return (
    <form onSubmit={handleSubmit}>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <MemoizedButton onClick={handleSubmit}>Search</MemoizedButton>
    </form>
  );
}
```

---

## When Memoization Helps

Memoization helps in two scenarios:

### 1. Expensive Calculations

If computation takes significant time (>1ms), cache it:

```tsx
function DataGrid({ rows, columns }: Props) {
  // Sorting 10,000 rows is expensive
  const sortedRows = useMemo(
    () => [...rows].sort((a, b) => a[sortColumn] - b[sortColumn]),
    [rows, sortColumn]
  );

  return <Grid rows={sortedRows} columns={columns} />;
}
```

### 2. Referential Equality for Memoized Children

When passing callbacks or objects to memoized components:

```tsx
const MemoizedChild = memo(function Child({ onClick, config }: Props) {
  return <button onClick={onClick}>Click</button>;
});

function Parent() {
  // Without useCallback, Child re-renders every time Parent renders
  const handleClick = useCallback(() => {
    console.log('clicked');
  }, []);

  // Without useMemo, Child re-renders every time Parent renders
  const config = useMemo(() => ({ theme: 'dark' }), []);

  return <MemoizedChild onClick={handleClick} config={config} />;
}
```

<Callout type="warning" title="Both Sides Matter">
`useCallback` only helps if the receiving component is memoized with `memo()`. Without `memo`, the child re-renders anyway regardless of prop stability.
</Callout>

---

## When Memoization Doesn't Help

Most of the time:

```tsx
// ❌ Unnecessary: Filtering is fast
const filtered = useMemo(
  () => items.filter(i => i.active),
  [items]
);

// ❌ Unnecessary: Child isn't memoized
const handleClick = useCallback(() => {
  setCount(c => c + 1);
}, []);

return <button onClick={handleClick}>+</button>; // Regular button, not memoized

// ❌ Unnecessary: Simple value
const doubled = useMemo(() => count * 2, [count]);
```

### The Cost of Memoization

Memoization isn't free:
- Memory for cached values
- Comparison of dependencies every render
- Code complexity

If the computation is cheap, memoization adds overhead without benefit.

---

## The React Compiler

The React Compiler (React Forget) automatically memoizes your components. It analyzes your code and inserts `useMemo` and `useCallback` where beneficial.

### Before Compiler (Manual)

```tsx
function TodoList({ todos, filter }) {
  const filteredTodos = useMemo(
    () => todos.filter(t => t.status === filter),
    [todos, filter]
  );

  const handleToggle = useCallback(
    (id) => toggleTodo(id),
    []
  );

  return filteredTodos.map(todo => (
    <TodoItem key={todo.id} todo={todo} onToggle={handleToggle} />
  ));
}
```

### With Compiler (Automatic)

```tsx
function TodoList({ todos, filter }) {
  // Compiler adds memoization automatically
  const filteredTodos = todos.filter(t => t.status === filter);

  const handleToggle = (id) => toggleTodo(id);

  return filteredTodos.map(todo => (
    <TodoItem key={todo.id} todo={todo} onToggle={handleToggle} />
  ));
}
```

The compiler:
- Analyzes which values need memoization
- Inserts memoization automatically
- Does it more precisely than humans typically do

---

## Writing Compiler-Friendly Code

The compiler requires your code to follow React's rules:

### 1. Components Must Be Pure

```tsx
// ❌ Impure: Side effect during render
function Bad() {
  globalCounter++; // Compiler can't optimize this safely
  return <div>{globalCounter}</div>;
}

// ✅ Pure: No side effects during render
function Good() {
  const [count, setCount] = useState(0);
  return <div>{count}</div>;
}
```

### 2. Don't Mutate Props or State

```tsx
// ❌ Mutation: Compiler can't track this
function Bad({ items }) {
  items.sort(); // Mutates props!
  return <List items={items} />;
}

// ✅ Immutable: Create new array
function Good({ items }) {
  const sorted = [...items].sort();
  return <List items={sorted} />;
}
```

### 3. Stable Dependencies

```tsx
// ❌ Unstable: Object created every render
function Bad() {
  const config = { theme: 'dark' }; // New object each render

  useEffect(() => {
    initLibrary(config);
  }, [config]); // Runs every render!
}

// ✅ Stable: Memoized or outside component
const config = { theme: 'dark' }; // Outside component

function Good() {
  useEffect(() => {
    initLibrary(config);
  }, [config]); // Stable reference
}
```

---

## Current Best Practices

Until the compiler is widely adopted:

### Do Memoize

- Expensive calculations (>1ms)
- Values passed to memoized children
- Values in dependency arrays that would cause unwanted re-runs

### Don't Memoize

- Simple calculations
- Callbacks passed to non-memoized components
- "Just in case" optimization

### Profile First

```tsx
// Use React DevTools Profiler to identify slow components
// Only then add memoization where it matters
```

---

## Common Patterns

### Memoized Child Components

```tsx
const ExpensiveList = memo(function ExpensiveList({ items, onSelect }: Props) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id} onClick={() => onSelect(item.id)}>
          {item.name}
        </li>
      ))}
    </ul>
  );
});

function Parent() {
  const [items] = useState(generateLargeList());
  const [selected, setSelected] = useState<string | null>(null);

  // Stable callback for memoized child
  const handleSelect = useCallback((id: string) => {
    setSelected(id);
  }, []);

  return (
    <div>
      <p>Selected: {selected}</p>
      <ExpensiveList items={items} onSelect={handleSelect} />
    </div>
  );
}
```

### Derived State with useMemo

```tsx
function Dashboard({ data }: Props) {
  // Expensive aggregations
  const stats = useMemo(() => ({
    total: data.reduce((sum, d) => sum + d.value, 0),
    average: data.reduce((sum, d) => sum + d.value, 0) / data.length,
    max: Math.max(...data.map(d => d.value)),
    min: Math.min(...data.map(d => d.value)),
  }), [data]);

  return (
    <div>
      <StatCard title="Total" value={stats.total} />
      <StatCard title="Average" value={stats.average} />
      <StatCard title="Max" value={stats.max} />
      <StatCard title="Min" value={stats.min} />
    </div>
  );
}
```

### Context Value Memoization

```tsx
function AppProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [theme, setTheme] = useState<'light' | 'dark'>('light');

  // Memoize to prevent unnecessary consumer re-renders
  const value = useMemo(
    () => ({ user, theme, setUser, setTheme }),
    [user, theme]
  );

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}
```

---

## Summary

`useMemo` and `useCallback` optimize performance through caching:

- **useMemo**: Cache computed values
- **useCallback**: Cache function references
- **Only helps when**: Computation is expensive OR child is memoized
- **React Compiler**: Will automate most memoization
- **Best practice**: Profile first, memoize only where needed

<HookCard
  name="useMemo & useCallback"
  signature="useMemo(() => value, [deps]) / useCallback(fn, [deps])"
  description="Cache values and functions between renders. Useful for expensive calculations and stable references for memoized children. The React Compiler will automate most cases."
  category="performance"
/>

---

## Exercises

### Warm-up

This component re-renders the entire list when the input changes. Fix it:

```tsx
function FilterableList({ items }) {
  const [filter, setFilter] = useState('');

  const filtered = items.filter(i => i.name.includes(filter));

  return (
    <div>
      <input value={filter} onChange={e => setFilter(e.target.value)} />
      {filtered.map(item => (
        <ExpensiveItem key={item.id} item={item} />
      ))}
    </div>
  );
}
```

### Core

Build a data table component that:
- Sorts by clicking column headers
- Filters by text input
- Memoizes sorted/filtered results
- Only re-renders rows that changed
- Handles 10,000 rows smoothly

### Stretch

Create a virtualized list with memoization:
- Only renders visible items
- Memoizes row components
- Maintains scroll position
- Handles dynamic row heights
- Profile and verify render counts
