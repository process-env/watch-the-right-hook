# use(): Async Data and Context in Components

React 19 introduces `use()`, a new primitive that can read promises and context in ways no other hook can. Unlike other hooks, `use()` can be called conditionally. It's the foundation for Suspense-based data fetching.

## Learning Outcomes

After reading this chapter, you will:

- Understand how `use()` differs from other hooks
- Read promises with Suspense using `use()`
- Use `use()` for conditional context access
- Know when to use `use()` vs `useContext` vs `await`
- Build Suspense-ready data fetching patterns

---

## What Makes use() Special

`use()` breaks the "only call hooks at the top level" rule. It can be called:
- Inside conditionals
- Inside loops
- After early returns

This is possible because `use()` doesn't maintain state between renders—it reads from an external source (a promise or context).

```tsx
function Component({ shouldLoad }: { shouldLoad: boolean }) {
  // ✅ This is allowed with use()!
  if (shouldLoad) {
    const data = use(fetchData());
  }

  // ❌ This would be illegal with useContext
  // if (shouldLoad) {
  //   const theme = useContext(ThemeContext);
  // }
}
```

---

## Reading Promises with use()

`use()` integrates with Suspense to handle async data:

```tsx
import { use, Suspense } from 'react';

async function fetchUser(id: string): Promise<User> {
  const res = await fetch(`/api/users/${id}`);
  return res.json();
}

function UserProfile({ userId }: { userId: string }) {
  // use() suspends until the promise resolves
  const user = use(fetchUser(userId));

  return (
    <div>
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
}

function App() {
  return (
    <Suspense fallback={<Loading />}>
      <UserProfile userId="123" />
    </Suspense>
  );
}
```

When `use()` encounters an unresolved promise:
1. It throws the promise (yes, throws)
2. React catches it and shows the Suspense fallback
3. When the promise resolves, React re-renders with the data

<Callout type="warning" title="Promise Caching Required">
If you call `fetchUser(userId)` directly in render, you create a new promise every render, causing an infinite loop. You must cache or dedupe the promise.
</Callout>

---

## Caching Promises

The promise passed to `use()` must be stable across renders:

```tsx
// ❌ Creates new promise every render = infinite loop
function UserProfile({ userId }: { userId: string }) {
  const user = use(fetchUser(userId)); // New promise each render!
}

// ✅ Cache the promise
const cache = new Map<string, Promise<User>>();

function fetchUserCached(id: string): Promise<User> {
  if (!cache.has(id)) {
    cache.set(id, fetchUser(id));
  }
  return cache.get(id)!;
}

function UserProfile({ userId }: { userId: string }) {
  const user = use(fetchUserCached(userId)); // Same promise reference
}
```

In practice, you'll use a library that handles this:
- React Query / TanStack Query
- SWR
- Next.js Server Components (promises are cached automatically)

---

## use() with Context

`use()` can also read context, with the advantage of conditional access:

```tsx
function Component({ useTheme }: { useTheme: boolean }) {
  // Conditionally read context
  const theme = useTheme ? use(ThemeContext) : 'default';

  return <div className={theme}>Content</div>;
}
```

Compare with `useContext`:

```tsx
// useContext: Must always be called
const theme = useContext(ThemeContext);
const actualTheme = useTheme ? theme : 'default';

// use(): Can skip the read entirely
const theme = useTheme ? use(ThemeContext) : 'default';
```

For context, `use()` and `useContext` are mostly interchangeable. Use `useContext` for consistency with other hooks; use `use()` when you need conditional access.

---

## Server Components and use()

In Server Components, you can `await` directly:

```tsx
// Server Component - can use await
async function UserProfile({ userId }: { userId: string }) {
  const user = await fetchUser(userId);

  return (
    <div>
      <h1>{user.name}</h1>
    </div>
  );
}
```

In Client Components, use `use()`:

```tsx
'use client'

// Client Component - use use() with Suspense
function UserProfile({ userPromise }: { userPromise: Promise<User> }) {
  const user = use(userPromise);

  return (
    <div>
      <h1>{user.name}</h1>
    </div>
  );
}
```

### Passing Promises from Server to Client

A powerful pattern: create the promise on the server, resolve it on the client:

```tsx
// Server Component
async function Page({ params }: { params: { id: string } }) {
  // Start fetching but don't await
  const userPromise = fetchUser(params.id);

  return (
    <Suspense fallback={<Loading />}>
      {/* Pass the promise to a client component */}
      <UserDetails userPromise={userPromise} />
    </Suspense>
  );
}

// Client Component
'use client'
function UserDetails({ userPromise }: { userPromise: Promise<User> }) {
  const user = use(userPromise);
  return <div>{user.name}</div>;
}
```

This lets the fetch start on the server while the client handles the UI.

---

## Error Handling

Errors in `use()` propagate to the nearest Error Boundary:

```tsx
function UserProfile({ userId }: { userId: string }) {
  const user = use(fetchUserCached(userId));
  return <div>{user.name}</div>;
}

function App() {
  return (
    <ErrorBoundary fallback={<Error />}>
      <Suspense fallback={<Loading />}>
        <UserProfile userId="123" />
      </Suspense>
    </ErrorBoundary>
  );
}
```

If the promise rejects:
1. `use()` throws the error
2. The Error Boundary catches it
3. The fallback UI renders

---

## Parallel Data Fetching

Fetch multiple resources in parallel:

```tsx
function Dashboard({ userId }: { userId: string }) {
  return (
    <div>
      <Suspense fallback={<UserSkeleton />}>
        <UserInfo userId={userId} />
      </Suspense>

      <Suspense fallback={<PostsSkeleton />}>
        <UserPosts userId={userId} />
      </Suspense>

      <Suspense fallback={<StatsSkeleton />}>
        <UserStats userId={userId} />
      </Suspense>
    </div>
  );
}

function UserInfo({ userId }: { userId: string }) {
  const user = use(fetchUserCached(userId));
  return <div>{user.name}</div>;
}

function UserPosts({ userId }: { userId: string }) {
  const posts = use(fetchPostsCached(userId));
  return <ul>{posts.map(p => <li key={p.id}>{p.title}</li>)}</ul>;
}

function UserStats({ userId }: { userId: string }) {
  const stats = use(fetchStatsCached(userId));
  return <div>{stats.followers} followers</div>;
}
```

Each Suspense boundary is independent—components load as their data arrives.

---

## Sequential vs Parallel

Be careful not to accidentally serialize fetches:

```tsx
// ❌ Sequential: posts waits for user
function Profile({ userId }: { userId: string }) {
  const user = use(fetchUser(userId));
  const posts = use(fetchPosts(userId)); // Starts after user loads

  return <div>{user.name}: {posts.length} posts</div>;
}

// ✅ Parallel: both start immediately
function Profile({ userId }: { userId: string }) {
  // Start both fetches
  const userPromise = fetchUserCached(userId);
  const postsPromise = fetchPostsCached(userId);

  // Read both (order doesn't matter since both are started)
  const user = use(userPromise);
  const posts = use(postsPromise);

  return <div>{user.name}: {posts.length} posts</div>;
}
```

---

## use() vs Traditional Patterns

| Pattern | When to Use |
|---------|-------------|
| `use()` + Suspense | Declarative loading states, streaming SSR |
| `useEffect` + `useState` | When you need fine control over loading/error states |
| `await` in Server Components | Server-only data fetching |
| React Query / SWR | Complex caching, refetching, mutations |

`use()` is best when:
- You want Suspense integration
- Data is fetch-once (not frequently refetched)
- You're passing promises from Server to Client Components

Traditional patterns are better when:
- You need manual retry logic
- You need to track loading progress
- You need to refetch on user action

---

## TypeScript with use()

`use()` infers the resolved type from the promise:

```tsx
// Promise<User> -> User
const user = use(fetchUser(id));
// user is typed as User

// Context with default
const ThemeContext = createContext<'light' | 'dark'>('light');
const theme = use(ThemeContext);
// theme is typed as 'light' | 'dark'

// Context without default
const AuthContext = createContext<User | null>(null);
const user = use(AuthContext);
// user is typed as User | null
```

---

## Summary

`use()` is React 19's primitive for reading async data and context:

- Can be called conditionally (unlike other hooks)
- Integrates with Suspense for loading states
- Requires stable promise references (cache or dedupe)
- Works with both promises and context
- Powers the Server → Client promise passing pattern

<HookCard
  name="use"
  signature="const value = use(promiseOrContext)"
  description="Read a promise or context value. Can be called conditionally. Suspends when reading unresolved promises."
  category="context"
/>

---

## Exercises

### Warm-up

Convert this useEffect pattern to use():

```tsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(u => {
      setUser(u);
      setLoading(false);
    });
  }, [userId]);

  if (loading) return <Loading />;
  return <div>{user.name}</div>;
}
```

### Core

Build a data fetching hook that:
- Uses `use()` internally
- Caches promises by key
- Supports cache invalidation
- Works with Suspense

```tsx
const user = useFetch(`/api/users/${id}`);
// Later:
invalidateCache(`/api/users/${id}`);
```

### Stretch

Create a prefetching system:
- `prefetch(key, fetcher)` - Start fetching before render
- `usePrefetched(key)` - Use the prefetched data with `use()`
- Works with route transitions (prefetch on link hover)
- TypeScript support for the fetcher return type
