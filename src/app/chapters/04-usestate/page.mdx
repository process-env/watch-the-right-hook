# useState: Local State Done Right

`useState` is the hook you'll use most. It holds a value, gives you a function to change it, and re-renders the component when you do. Simple—but there are patterns that make it powerful and pitfalls that cause bugs.

## Learning Outcomes

After reading this chapter, you will:

- Understand how useState works under the hood
- Know when to use functional updates vs direct values
- Handle objects and arrays without mutation bugs
- Implement controlled forms correctly
- Recognize when useState isn't enough

---

## The Basics

```tsx
const [state, setState] = useState(initialValue);
```

- `state`: The current value
- `setState`: Function to update it
- `initialValue`: Starting value (only used on first render)

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      Count: {count}
    </button>
  );
}
```

<Callout type="info" title="Naming Convention">
Destructure as `[thing, setThing]`. The setter is always `set` + capitalized name. This isn't enforced but it's universal.
</Callout>

---

## Initial Value: Value vs Function

The initial value can be a value or a function that returns a value.

```tsx
// Value: runs every render, result used only on first
const [items, setItems] = useState(getItemsFromStorage());

// Function: runs only on first render
const [items, setItems] = useState(() => getItemsFromStorage());
```

Use the function form (lazy initialization) when:
- Computing the initial value is expensive
- The initial value comes from localStorage, URL params, etc.
- You're parsing JSON or doing any I/O

```tsx
function Editor({ documentId }) {
  // ❌ Parses JSON on every render (wasteful)
  const [doc, setDoc] = useState(JSON.parse(localStorage.getItem(documentId) || '{}'));

  // ✅ Parses JSON only on mount
  const [doc, setDoc] = useState(() => {
    const saved = localStorage.getItem(documentId);
    return saved ? JSON.parse(saved) : {};
  });
}
```

---

## Updating State: Value vs Function

`setState` accepts either a new value or a function that receives the previous value.

```tsx
// Direct value
setCount(5);

// Functional update
setCount(prev => prev + 1);
```

**Use functional updates when the new state depends on the old state**, especially in:
- Event handlers that might batch
- Callbacks passed to child components
- Intervals and timeouts

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  // ❌ Bug: If clicked fast, might miss increments due to batching
  const handleClick = () => {
    setCount(count + 1);
    setCount(count + 1); // Still uses same `count` value!
  };

  // ✅ Correct: Each update sees the latest value
  const handleClick = () => {
    setCount(c => c + 1);
    setCount(c => c + 1); // Gets result of previous update
  };
}
```

<Callout type="warning" title="Stale Closures">
`count` in your handler is captured when the handler is created. If React batches updates, both `setCount(count + 1)` calls see the same `count`. Functional updates avoid this.
</Callout>

---

## Objects and Arrays: Immutable Updates

React uses reference equality to detect changes. Mutating an object doesn't change its reference, so React won't re-render.

```tsx
// ❌ Mutation: React doesn't see the change
const [user, setUser] = useState({ name: 'Alice', age: 30 });

const handleBirthday = () => {
  user.age += 1;      // Mutates the object
  setUser(user);      // Same reference, no re-render!
};

// ✅ Immutable: Create a new object
const handleBirthday = () => {
  setUser({ ...user, age: user.age + 1 });
};

// ✅ Or with functional update
const handleBirthday = () => {
  setUser(prev => ({ ...prev, age: prev.age + 1 }));
};
```

### Array Patterns

```tsx
const [items, setItems] = useState<string[]>([]);

// Add item
setItems([...items, newItem]);
setItems(prev => [...prev, newItem]);

// Remove item
setItems(items.filter(item => item.id !== idToRemove));

// Update item
setItems(items.map(item =>
  item.id === idToUpdate ? { ...item, done: true } : item
));

// Insert at index
setItems([
  ...items.slice(0, index),
  newItem,
  ...items.slice(index)
]);
```

### Nested Objects

For deeply nested state, spread at each level:

```tsx
const [form, setForm] = useState({
  user: {
    name: '',
    address: {
      city: '',
      zip: ''
    }
  }
});

// Update nested property
setForm(prev => ({
  ...prev,
  user: {
    ...prev.user,
    address: {
      ...prev.user.address,
      city: 'New York'
    }
  }
}));
```

<Callout type="tip" title="Consider useReducer">
If your state updates are getting this nested, `useReducer` or a state management library might be cleaner.
</Callout>

---

## Controlled Forms

A controlled input has its value managed by React state.

```tsx
function LoginForm() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    login(email, password);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={email}
        onChange={e => setEmail(e.target.value)}
      />
      <input
        type="password"
        value={password}
        onChange={e => setPassword(e.target.value)}
      />
      <button type="submit">Login</button>
    </form>
  );
}
```

### Single State for Multiple Fields

For forms with many fields, use an object:

```tsx
function ProfileForm() {
  const [form, setForm] = useState({
    name: '',
    email: '',
    bio: ''
  });

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setForm(prev => ({ ...prev, [name]: value }));
  };

  return (
    <form>
      <input name="name" value={form.name} onChange={handleChange} />
      <input name="email" value={form.email} onChange={handleChange} />
      <textarea name="bio" value={form.bio} onChange={handleChange} />
    </form>
  );
}
```

---

## State Batching

React batches state updates in event handlers. Multiple `setState` calls result in one re-render.

```tsx
function Form() {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  const reset = () => {
    setName('');   // Batched
    setEmail('');  // Batched
    // Only ONE re-render happens
  };
}
```

In React 18+, batching also works in:
- Promises
- setTimeout
- Native event handlers
- Any other async code

```tsx
// React 18+: Still batched
setTimeout(() => {
  setName('');
  setEmail('');
  // One re-render
}, 1000);
```

---

## When useState Isn't Enough

Consider alternatives when:

| Situation | Better Option |
|-----------|---------------|
| Complex state transitions | `useReducer` |
| State shared across components | `useContext` or state library |
| State from external source | `useSyncExternalStore` |
| Derived state | Compute during render |
| State that doesn't affect render | `useRef` |

### Derived State Anti-pattern

Don't store values that can be computed:

```tsx
// ❌ Redundant state
const [items, setItems] = useState([]);
const [count, setCount] = useState(0);

const addItem = (item) => {
  setItems([...items, item]);
  setCount(count + 1);  // Duplicate source of truth
};

// ✅ Compute derived values
const [items, setItems] = useState([]);
const count = items.length;  // Always in sync
```

---

## TypeScript Patterns

```tsx
// Inferred type
const [count, setCount] = useState(0);  // number

// Explicit type for complex values
const [user, setUser] = useState<User | null>(null);

// Type for arrays
const [items, setItems] = useState<Item[]>([]);

// Union types
const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle');
```

---

## Summary

`useState` is straightforward but has nuances:

- Use lazy initialization for expensive initial values
- Use functional updates when new state depends on old
- Never mutate state—always create new references
- Batch updates happen automatically in React 18+
- Derive values instead of storing redundant state

<HookCard
  name="useState"
  signature="const [state, setState] = useState(initial)"
  description="Holds a value that persists across renders and triggers re-renders when updated. The foundation of React state management."
  category="state"
/>

---

## Exercises

### Warm-up

Fix the bug in this counter that should increment by 3 on each click:

```tsx
function Counter() {
  const [count, setCount] = useState(0);

  const incrementByThree = () => {
    setCount(count + 1);
    setCount(count + 1);
    setCount(count + 1);
  };

  return <button onClick={incrementByThree}>Count: {count}</button>;
}
```

### Core

Build a todo list with these features:
- Add new todos
- Toggle todo completion
- Delete todos
- Show count of incomplete todos

Use a single `useState` with an array of `{ id, text, completed }` objects.

### Stretch

Create a `useUndo` hook that wraps `useState` and adds undo/redo functionality:

```tsx
const [value, setValue, { undo, redo, canUndo, canRedo }] = useUndo('');
```

The hook should:
- Track history of values
- Support undo/redo operations
- Report whether undo/redo is available
