# Effect Anti-Patterns & Refactoring

Effects are overused. Many problems that seem to need effects have better solutions. This chapter catalogs the anti-patterns, shows why they're problematic, and demonstrates how to refactor them.

## Learning Outcomes

After reading this chapter, you will:

- Recognize the most common effect anti-patterns
- Know when to use event handlers instead of effects
- Eliminate unnecessary state synchronization effects
- Use useEffectEvent for stable callbacks (React 19)
- Refactor effects into cleaner patterns

---

## Anti-Pattern 1: Derived State in Effects

Setting state based on other state or props.

```tsx
// ❌ Anti-pattern: Effect to compute derived state
function FilteredList({ items, filter }: Props) {
  const [filteredItems, setFilteredItems] = useState<Item[]>([]);

  useEffect(() => {
    setFilteredItems(items.filter(item => item.category === filter));
  }, [items, filter]);

  return <List items={filteredItems} />;
}

// ✅ Solution: Calculate during render
function FilteredList({ items, filter }: Props) {
  const filteredItems = items.filter(item => item.category === filter);

  return <List items={filteredItems} />;
}

// ✅ If expensive, use useMemo
function FilteredList({ items, filter }: Props) {
  const filteredItems = useMemo(
    () => items.filter(item => item.category === filter),
    [items, filter]
  );

  return <List items={filteredItems} />;
}
```

**Why it's bad**: Extra render cycle, unnecessary state, more code.

**Rule**: If you can calculate it from props/state, calculate it during render.

---

## Anti-Pattern 2: Responding to Events with Effects

Using effects to handle user interactions.

```tsx
// ❌ Anti-pattern: Effect to respond to state change
function SearchForm() {
  const [query, setQuery] = useState('');

  useEffect(() => {
    if (query) {
      searchApi(query);
    }
  }, [query]);

  return <input value={query} onChange={e => setQuery(e.target.value)} />;
}

// ✅ Solution: Handle in event
function SearchForm() {
  const [query, setQuery] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    searchApi(query);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <button type="submit">Search</button>
    </form>
  );
}
```

**Why it's bad**: Effect runs on every keystroke. No control over when search happens.

**Rule**: If something happens because of a specific event, put it in the event handler.

---

## Anti-Pattern 3: Chains of Effects

Effects that trigger other effects.

```tsx
// ❌ Anti-pattern: Effect chain
function Checkout() {
  const [items, setItems] = useState<Item[]>([]);
  const [subtotal, setSubtotal] = useState(0);
  const [tax, setTax] = useState(0);
  const [total, setTotal] = useState(0);

  useEffect(() => {
    setSubtotal(items.reduce((sum, item) => sum + item.price, 0));
  }, [items]);

  useEffect(() => {
    setTax(subtotal * 0.1);
  }, [subtotal]);

  useEffect(() => {
    setTotal(subtotal + tax);
  }, [subtotal, tax]);

  // Three renders for one items change!
}

// ✅ Solution: Calculate everything at once
function Checkout() {
  const [items, setItems] = useState<Item[]>([]);

  const subtotal = items.reduce((sum, item) => sum + item.price, 0);
  const tax = subtotal * 0.1;
  const total = subtotal + tax;

  // One render, all values in sync
}
```

**Why it's bad**: Multiple renders, values can be temporarily out of sync.

**Rule**: Derive values in a single pass, not through cascading effects.

---

## Anti-Pattern 4: Resetting State on Prop Change

Using effects to reset state when props change.

```tsx
// ❌ Anti-pattern: Effect to reset state
function CommentForm({ postId }: { postId: string }) {
  const [comment, setComment] = useState('');

  useEffect(() => {
    setComment(''); // Reset when post changes
  }, [postId]);

  return <textarea value={comment} onChange={e => setComment(e.target.value)} />;
}

// ✅ Solution: Use key to remount
function PostPage({ postId }: { postId: string }) {
  return <CommentForm key={postId} postId={postId} />;
}

function CommentForm({ postId }: { postId: string }) {
  const [comment, setComment] = useState(''); // Fresh state on remount

  return <textarea value={comment} onChange={e => setComment(e.target.value)} />;
}
```

**Why it's bad**: Two renders (one with stale state, one after reset).

**Rule**: Use `key` to reset component state when identity changes.

---

## Anti-Pattern 5: Fetching Without Cleanup

Ignoring race conditions in fetch effects.

```tsx
// ❌ Anti-pattern: No race condition handling
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    fetchUser(userId).then(setUser);
    // If userId changes quickly, old response might arrive after new one
  }, [userId]);
}

// ✅ Solution: Ignore stale responses
function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    let ignore = false;

    fetchUser(userId).then(data => {
      if (!ignore) {
        setUser(data);
      }
    });

    return () => {
      ignore = true;
    };
  }, [userId]);
}

// ✅ Better: Use a data fetching library
function UserProfile({ userId }: { userId: string }) {
  const { data: user } = useQuery(['user', userId], () => fetchUser(userId));
}
```

**Why it's bad**: Race conditions cause stale data to overwrite fresh data.

**Rule**: Always handle cleanup in fetch effects, or use a library that does.

---

## Anti-Pattern 6: Initializing with Props

Using effects to initialize state from props.

```tsx
// ❌ Anti-pattern: Effect to initialize
function Editor({ initialContent }: { initialContent: string }) {
  const [content, setContent] = useState('');

  useEffect(() => {
    setContent(initialContent);
  }, []); // Only runs once, but still wrong

  return <textarea value={content} onChange={e => setContent(e.target.value)} />;
}

// ✅ Solution: Initialize useState directly
function Editor({ initialContent }: { initialContent: string }) {
  const [content, setContent] = useState(initialContent);

  return <textarea value={content} onChange={e => setContent(e.target.value)} />;
}
```

**Why it's bad**: Extra render, flash of empty content.

**Rule**: Initialize state directly in `useState`. That's what the argument is for.

---

## Anti-Pattern 7: Notifying Parent of State Changes

Using effects to sync child state with parent.

```tsx
// ❌ Anti-pattern: Effect to notify parent
function Toggle({ onChange }: { onChange: (on: boolean) => void }) {
  const [on, setOn] = useState(false);

  useEffect(() => {
    onChange(on);
  }, [on, onChange]);

  return <button onClick={() => setOn(!on)}>{on ? 'ON' : 'OFF'}</button>;
}

// ✅ Solution: Call in event handler
function Toggle({ onChange }: { onChange: (on: boolean) => void }) {
  const [on, setOn] = useState(false);

  const handleClick = () => {
    const newValue = !on;
    setOn(newValue);
    onChange(newValue);
  };

  return <button onClick={handleClick}>{on ? 'ON' : 'OFF'}</button>;
}

// ✅ Even better: Lift state up
function Toggle({ on, onToggle }: { on: boolean; onToggle: () => void }) {
  return <button onClick={onToggle}>{on ? 'ON' : 'OFF'}</button>;
}
```

**Why it's bad**: Effect runs after render, causing another render in parent.

**Rule**: Notify parents in event handlers, not effects.

---

## useEffectEvent: Stable Callbacks

React 19 introduces `useEffectEvent` for callbacks that shouldn't trigger re-sync:

```tsx
// ❌ Problem: Effect re-runs when onVisit changes
function ChatRoom({ roomId, onVisit }: Props) {
  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    onVisit(roomId); // But onVisit might be unstable

    return () => connection.disconnect();
  }, [roomId, onVisit]); // onVisit in deps causes issues
}

// ✅ Solution: useEffectEvent (React 19)
function ChatRoom({ roomId, onVisit }: Props) {
  const onVisitEvent = useEffectEvent((room: string) => {
    onVisit(room);
  });

  useEffect(() => {
    const connection = createConnection(roomId);
    connection.connect();
    onVisitEvent(roomId); // Always sees latest onVisit

    return () => connection.disconnect();
  }, [roomId]); // onVisitEvent not in deps
}
```

`useEffectEvent` creates a stable function that always sees latest props/state.

<Callout type="info" title="Experimental">
As of late 2024, `useEffectEvent` is available in React 19 canary builds. Check the React docs for current status.
</Callout>

---

## Refactoring Checklist

When you see an effect, ask:

1. **Can I calculate this during render?**
   - Yes → Remove effect, calculate inline or with `useMemo`

2. **Does this respond to a user event?**
   - Yes → Move to event handler

3. **Am I syncing state with state?**
   - Yes → Derive instead of sync

4. **Am I resetting state when props change?**
   - Yes → Use `key` to remount

5. **Am I notifying a parent?**
   - Yes → Call in event handler or lift state

6. **Is this initializing state from props?**
   - Yes → Use `useState(initialValue)` directly

7. **Is this actually syncing with an external system?**
   - Yes → Keep the effect, ensure proper cleanup

---

## Summary

Most effects are unnecessary. Before writing an effect, consider:

| Instead of Effect | Use |
|-------------------|-----|
| Derived state | Calculate during render |
| Response to event | Event handler |
| State chains | Single calculation |
| State reset on prop change | `key` prop |
| Initialize from props | `useState(prop)` |
| Notify parent | Event handler |

The only legitimate use for effects is synchronizing with external systems.

<HookCard
  name="Effect Refactoring"
  signature="Ask: Is this syncing with an external system?"
  description="Most effects can be replaced with render calculations, event handlers, or component restructuring. Effects are for external synchronization only."
  category="effect"
/>

---

## Exercises

### Warm-up

Refactor this component to eliminate the unnecessary effect:

```tsx
function UserGreeting({ firstName, lastName }) {
  const [fullName, setFullName] = useState('');

  useEffect(() => {
    setFullName(`${firstName} ${lastName}`);
  }, [firstName, lastName]);

  return <h1>Hello, {fullName}!</h1>;
}
```

### Core

This component has multiple anti-patterns. Fix them all:

```tsx
function ProductList({ category, onSelect }) {
  const [products, setProducts] = useState([]);
  const [filtered, setFiltered] = useState([]);
  const [selected, setSelected] = useState(null);

  useEffect(() => {
    fetchProducts().then(setProducts);
  }, []);

  useEffect(() => {
    setFiltered(products.filter(p => p.category === category));
  }, [products, category]);

  useEffect(() => {
    if (selected) {
      onSelect(selected);
    }
  }, [selected, onSelect]);

  return (
    <ul>
      {filtered.map(p => (
        <li key={p.id} onClick={() => setSelected(p)}>
          {p.name}
        </li>
      ))}
    </ul>
  );
}
```

### Stretch

Build a form component that:
- Has controlled inputs
- Validates on blur (not on every keystroke)
- Shows derived error state (no effect for validation)
- Notifies parent on submit (not via effect)
- Resets when a `formKey` prop changes (using key, not effect)
- Uses `useEffectEvent` for stable analytics callback
