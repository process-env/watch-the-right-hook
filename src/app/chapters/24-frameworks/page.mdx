# Hooks with Frameworks: Next.js, Remix, and Expo

Hooks work the same everywhere, but frameworks add context. Server Components change what hooks are available. Loaders change how you fetch data. Native platforms have different APIs. This chapter covers framework-specific patterns.

## Learning Outcomes

After reading this chapter, you will:

- Know which hooks work in Server vs Client Components
- Use Next.js App Router patterns effectively
- Understand Remix's loader/action model
- Handle React Native differences in Expo
- Avoid common framework-specific mistakes

---

## Server vs Client Components

React Server Components (RSC) changed the game. Some hooks only work on the client.

### Hooks in Server Components

Server Components can use:
- `use()` for reading promises and context
- `useId()` for generating stable IDs

Server Components **cannot** use:
- `useState` / `useReducer` (no state on server)
- `useEffect` / `useLayoutEffect` (no effects)
- `useRef` (no persistent refs)
- `useContext` (but `use(Context)` works)
- Any hook that depends on browser APIs

```tsx
// ✅ Server Component with useId
async function ServerForm() {
  const id = useId();
  const data = await fetchData();

  return (
    <form>
      <label htmlFor={id}>Name</label>
      <input id={id} defaultValue={data.name} />
    </form>
  );
}

// ❌ Won't work: useState in Server Component
async function BrokenComponent() {
  const [count, setCount] = useState(0); // Error!
  return <div>{count}</div>;
}
```

### The 'use client' Boundary

Mark components that need client hooks:

```tsx
// components/Counter.tsx
'use client';

import { useState } from 'react';

export function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(c => c + 1)}>
      Count: {count}
    </button>
  );
}

// app/page.tsx (Server Component)
import { Counter } from '@/components/Counter';

export default async function Page() {
  const data = await fetchData(); // Server-side fetch

  return (
    <div>
      <h1>{data.title}</h1>
      <Counter /> {/* Client component island */}
    </div>
  );
}
```

---

## Next.js App Router Patterns

### Data Fetching: Server Components First

Prefer fetching in Server Components over client hooks:

```tsx
// ❌ Old pattern: Client-side fetching
'use client';

function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchUser(userId).then(setUser).finally(() => setLoading(false));
  }, [userId]);

  if (loading) return <Skeleton />;
  return <Profile user={user} />;
}

// ✅ New pattern: Server Component
async function UserProfile({ userId }: { userId: string }) {
  const user = await fetchUser(userId);
  return <Profile user={user} />;
}
```

### When You Need Client Hooks

Use client hooks for:
- Interactive UI state (modals, dropdowns)
- Form state and validation
- Real-time updates (WebSockets)
- Browser API access

```tsx
'use client';

import { useState, useEffect } from 'react';

function LiveNotifications({ userId }: { userId: string }) {
  const [notifications, setNotifications] = useState<Notification[]>([]);

  useEffect(() => {
    const ws = new WebSocket(`/api/notifications/${userId}`);

    ws.onmessage = (event) => {
      setNotifications(prev => [...prev, JSON.parse(event.data)]);
    };

    return () => ws.close();
  }, [userId]);

  return <NotificationList items={notifications} />;
}
```

### Server Actions with useActionState

Next.js supports Server Actions with form hooks:

```tsx
// app/actions.ts
'use server';

export async function createPost(prevState: any, formData: FormData) {
  const title = formData.get('title') as string;
  const content = formData.get('content') as string;

  try {
    await db.posts.create({ title, content });
    return { success: true, message: 'Post created!' };
  } catch (error) {
    return { success: false, message: 'Failed to create post' };
  }
}

// components/PostForm.tsx
'use client';

import { useActionState } from 'react';
import { createPost } from '@/app/actions';

export function PostForm() {
  const [state, formAction, isPending] = useActionState(createPost, null);

  return (
    <form action={formAction}>
      <input name="title" placeholder="Title" disabled={isPending} />
      <textarea name="content" placeholder="Content" disabled={isPending} />
      <button type="submit" disabled={isPending}>
        {isPending ? 'Creating...' : 'Create Post'}
      </button>
      {state?.message && <p>{state.message}</p>}
    </form>
  );
}
```

### useParams and useSearchParams

Access route parameters in client components:

```tsx
'use client';

import { useParams, useSearchParams } from 'next/navigation';

function ProductPage() {
  const params = useParams();
  const searchParams = useSearchParams();

  const productId = params.id as string;
  const variant = searchParams.get('variant');

  // Use productId and variant...
}
```

### useRouter for Navigation

```tsx
'use client';

import { useRouter, usePathname } from 'next/navigation';

function Navigation() {
  const router = useRouter();
  const pathname = usePathname();

  const handleLogout = async () => {
    await logout();
    router.push('/login');
    router.refresh(); // Refresh Server Component data
  };

  return (
    <nav>
      <Link href="/" className={pathname === '/' ? 'active' : ''}>Home</Link>
      <button onClick={handleLogout}>Logout</button>
    </nav>
  );
}
```

---

## Remix Patterns

Remix has a different philosophy: loaders and actions instead of hooks for data.

### Loaders Instead of useEffect

```tsx
// ❌ React pattern: Effect for data
function UserPage() {
  const [user, setUser] = useState(null);

  useEffect(() => {
    fetchUser(params.id).then(setUser);
  }, [params.id]);

  return <Profile user={user} />;
}

// ✅ Remix pattern: Loader
import { json, LoaderFunctionArgs } from '@remix-run/node';
import { useLoaderData } from '@remix-run/react';

export async function loader({ params }: LoaderFunctionArgs) {
  const user = await fetchUser(params.id);
  return json({ user });
}

export default function UserPage() {
  const { user } = useLoaderData<typeof loader>();
  return <Profile user={user} />;
}
```

### Actions Instead of Form Hooks

```tsx
// ❌ React pattern: Form state + submit handler
function ContactForm() {
  const [formData, setFormData] = useState({ name: '', email: '' });
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsSubmitting(true);
    await submitContact(formData);
    setIsSubmitting(false);
  };

  return <form onSubmit={handleSubmit}>...</form>;
}

// ✅ Remix pattern: Action + useNavigation
import { ActionFunctionArgs, redirect } from '@remix-run/node';
import { Form, useNavigation } from '@remix-run/react';

export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  await submitContact(Object.fromEntries(formData));
  return redirect('/thank-you');
}

export default function ContactForm() {
  const navigation = useNavigation();
  const isSubmitting = navigation.state === 'submitting';

  return (
    <Form method="post">
      <input name="name" disabled={isSubmitting} />
      <input name="email" type="email" disabled={isSubmitting} />
      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Sending...' : 'Send'}
      </button>
    </Form>
  );
}
```

### Remix Hooks

Remix provides specialized hooks:

```tsx
import {
  useLoaderData,    // Access loader data
  useActionData,    // Access action return value
  useNavigation,    // Track navigation state
  useSubmit,        // Programmatic form submission
  useFetcher,       // Non-navigation data mutations
  useMatches,       // Access parent route data
  useRouteError,    // Error boundary data
} from '@remix-run/react';

// useFetcher for mutations without navigation
function LikeButton({ postId }: { postId: string }) {
  const fetcher = useFetcher();
  const isLiking = fetcher.state === 'submitting';

  return (
    <fetcher.Form method="post" action={`/posts/${postId}/like`}>
      <button type="submit" disabled={isLiking}>
        {isLiking ? '...' : '❤️'}
      </button>
    </fetcher.Form>
  );
}
```

### When to Use React Hooks in Remix

Use standard React hooks for:
- Local UI state (modals, tabs)
- Client-only features
- Third-party integrations

```tsx
// Local state is still useState
function Accordion({ items }: { items: Item[] }) {
  const [openIndex, setOpenIndex] = useState<number | null>(null);

  return (
    <div>
      {items.map((item, index) => (
        <AccordionItem
          key={item.id}
          item={item}
          isOpen={openIndex === index}
          onToggle={() => setOpenIndex(openIndex === index ? null : index)}
        />
      ))}
    </div>
  );
}
```

---

## Expo / React Native Patterns

React Native has the same hooks, different APIs.

### Platform-Specific Hooks

```tsx
import { useState, useEffect } from 'react';
import { Dimensions, Platform, Keyboard } from 'react-native';

// Window dimensions hook
function useWindowDimensions() {
  const [dimensions, setDimensions] = useState(Dimensions.get('window'));

  useEffect(() => {
    const subscription = Dimensions.addEventListener('change', ({ window }) => {
      setDimensions(window);
    });

    return () => subscription.remove();
  }, []);

  return dimensions;
}

// Keyboard visibility hook
function useKeyboardVisible() {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    const showEvent = Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow';
    const hideEvent = Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide';

    const showSub = Keyboard.addListener(showEvent, () => setIsVisible(true));
    const hideSub = Keyboard.addListener(hideEvent, () => setIsVisible(false));

    return () => {
      showSub.remove();
      hideSub.remove();
    };
  }, []);

  return isVisible;
}
```

### Expo-Specific Hooks

Expo provides hooks for device features:

```tsx
import { useState, useEffect } from 'react';
import * as Location from 'expo-location';
import * as Notifications from 'expo-notifications';
import { useAssets } from 'expo-asset';
import { useFonts } from 'expo-font';

// Location hook
function useLocation() {
  const [location, setLocation] = useState<Location.LocationObject | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    (async () => {
      const { status } = await Location.requestForegroundPermissionsAsync();

      if (status !== 'granted') {
        setError('Permission denied');
        return;
      }

      const location = await Location.getCurrentPositionAsync({});
      setLocation(location);
    })();
  }, []);

  return { location, error };
}

// Notification hook
function usePushNotifications() {
  const [expoPushToken, setExpoPushToken] = useState<string | null>(null);
  const [notification, setNotification] = useState<Notifications.Notification | null>(null);

  useEffect(() => {
    registerForPushNotifications().then(setExpoPushToken);

    const subscription = Notifications.addNotificationReceivedListener(setNotification);

    return () => subscription.remove();
  }, []);

  return { expoPushToken, notification };
}

// Font loading (Expo provides this)
function App() {
  const [fontsLoaded] = useFonts({
    'Inter-Regular': require('./assets/fonts/Inter-Regular.ttf'),
    'Inter-Bold': require('./assets/fonts/Inter-Bold.ttf'),
  });

  if (!fontsLoaded) {
    return <LoadingScreen />;
  }

  return <MainApp />;
}
```

### Navigation in React Native

React Navigation uses hooks:

```tsx
import {
  useNavigation,
  useRoute,
  useFocusEffect,
  useIsFocused,
} from '@react-navigation/native';
import { useCallback } from 'react';

function ProfileScreen() {
  const navigation = useNavigation();
  const route = useRoute();
  const isFocused = useIsFocused();

  // Run effect when screen comes into focus
  useFocusEffect(
    useCallback(() => {
      fetchProfile();

      return () => {
        // Cleanup when screen loses focus
      };
    }, [])
  );

  return (
    <View>
      <Text>User: {route.params?.userId}</Text>
      <Button
        title="Settings"
        onPress={() => navigation.navigate('Settings')}
      />
    </View>
  );
}
```

### AsyncStorage Instead of localStorage

```tsx
import AsyncStorage from '@react-native-async-storage/async-storage';

function useAsyncStorage<T>(key: string, initialValue: T) {
  const [storedValue, setStoredValue] = useState<T>(initialValue);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    AsyncStorage.getItem(key)
      .then(value => {
        if (value !== null) {
          setStoredValue(JSON.parse(value));
        }
      })
      .finally(() => setLoading(false));
  }, [key]);

  const setValue = useCallback(async (value: T | ((prev: T) => T)) => {
    const valueToStore = value instanceof Function ? value(storedValue) : value;
    setStoredValue(valueToStore);
    await AsyncStorage.setItem(key, JSON.stringify(valueToStore));
  }, [key, storedValue]);

  return [storedValue, setValue, loading] as const;
}
```

---

## Common Framework Mistakes

### Mistake 1: useEffect in Server Components

```tsx
// ❌ Server Component with useEffect
async function ServerComponent() {
  useEffect(() => {
    // This will never run!
  }, []);

  return <div>...</div>;
}

// ✅ Move to Client Component
'use client';

function ClientComponent() {
  useEffect(() => {
    // This runs on the client
  }, []);

  return <div>...</div>;
}
```

### Mistake 2: Fetching in Client Components (Next.js)

```tsx
// ❌ Unnecessary client-side fetch
'use client';

function UserList() {
  const [users, setUsers] = useState([]);

  useEffect(() => {
    fetch('/api/users').then(r => r.json()).then(setUsers);
  }, []);

  return <List items={users} />;
}

// ✅ Fetch in Server Component
async function UserList() {
  const users = await fetchUsers(); // Direct database access possible
  return <List items={users} />;
}
```

### Mistake 3: useState for URL State (Remix/Next.js)

```tsx
// ❌ Local state for URL-worthy data
function ProductList() {
  const [filter, setFilter] = useState('all');
  const [sort, setSort] = useState('name');

  // Lost on refresh, not shareable
}

// ✅ URL state with search params
'use client';

import { useSearchParams, useRouter } from 'next/navigation';

function ProductList() {
  const searchParams = useSearchParams();
  const router = useRouter();

  const filter = searchParams.get('filter') ?? 'all';
  const sort = searchParams.get('sort') ?? 'name';

  const updateParams = (key: string, value: string) => {
    const params = new URLSearchParams(searchParams);
    params.set(key, value);
    router.push(`?${params.toString()}`);
  };

  // Shareable, survives refresh
}
```

---

## Summary

Framework-specific hook patterns:

| Framework | Data Fetching | Forms | Navigation |
|-----------|--------------|-------|------------|
| Next.js App Router | Server Components | useActionState + Server Actions | useRouter, useParams |
| Remix | Loaders | Actions + Form | useNavigate, useMatches |
| Expo | useFetch / TanStack Query | useState | React Navigation hooks |

Key principles:
- Server Components can't use most hooks
- Prefer server-side data fetching when possible
- Use URL state for shareable/bookmarkable state
- Platform-specific hooks for device features

<HookCard
  name="Framework Patterns"
  signature="'use client' + Server Components + Framework Hooks"
  description="Different frameworks have different patterns. Server Components limit hook usage. Use framework-provided hooks for routing, data, and forms."
  category="pattern"
/>

---

## Exercises

### Warm-up

Convert this client component to use Server Components properly:

```tsx
'use client';

function BlogPost({ postId }) {
  const [post, setPost] = useState(null);
  const [comments, setComments] = useState([]);

  useEffect(() => {
    fetchPost(postId).then(setPost);
    fetchComments(postId).then(setComments);
  }, [postId]);

  return (
    <article>
      <h1>{post?.title}</h1>
      <p>{post?.content}</p>
      <CommentForm postId={postId} />
      <CommentList comments={comments} />
    </article>
  );
}
```

### Core

Build a product search page in Next.js that:
- Fetches initial products server-side
- Has client-side filters (category, price range)
- Persists filter state in URL
- Shows loading states during filter changes

### Stretch

Create a real-time chat feature for a Next.js app that:
- Loads message history server-side
- Connects to WebSocket for live updates
- Has optimistic message sending
- Handles reconnection gracefully
- Works with Server Actions for sending messages
