# useId: Stable IDs for Streaming & Accessibility

HTML elements often need unique IDs—for labels, ARIA attributes, and form associations. In server-rendered React, generating IDs is tricky: the server and client must produce the same IDs, and streaming complicates things further. `useId` solves this.

## Learning Outcomes

After reading this chapter, you will:

- Understand why generating IDs in React is problematic
- Use useId for accessible form labels
- Connect ARIA attributes reliably
- Handle multiple IDs in a single component
- Know when useId is (and isn't) needed

---

## The Problem: IDs in React

IDs must be unique across the entire document. In React, this is harder than it sounds:

### Problem 1: Server/Client Mismatch

```tsx
// ❌ Wrong: Different IDs on server vs client
let counter = 0;

function Input({ label }: { label: string }) {
  const id = `input-${counter++}`; // Increments differently on server vs client

  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input id={id} />
    </div>
  );
}
```

The server renders with `input-0`, but the client hydrates expecting a different count. Hydration fails.

### Problem 2: Streaming Order

With React 18+ streaming, components might render in different orders on server vs client. Any ID scheme based on render order breaks.

### Problem 3: Multiple Instances

```tsx
// ❌ Wrong: Hardcoded ID
function EmailInput() {
  return (
    <div>
      <label htmlFor="email">Email</label>
      <input id="email" type="email" />
    </div>
  );
}

// Two instances = duplicate IDs!
<EmailInput />
<EmailInput />
```

---

## useId: The Solution

`useId` generates stable, unique IDs that match between server and client:

```tsx
import { useId } from 'react';

function Input({ label }: { label: string }) {
  const id = useId();

  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input id={id} />
    </div>
  );
}
```

- Same ID on server and client
- Unique across all instances
- Works with streaming SSR
- Stable across re-renders

---

## How useId Works

`useId` generates IDs based on the component's position in the React tree, not render order:

```tsx
function Form() {
  return (
    <div>
      <Input label="Name" />     {/* :r0: */}
      <Input label="Email" />    {/* :r1: */}
      <Input label="Password" /> {/* :r2: */}
    </div>
  );
}
```

The IDs like `:r0:`, `:r1:` are deterministic based on tree structure. Even if components render in different orders during streaming, they get consistent IDs.

<Callout type="info" title="ID Format">
The exact format (`:r0:`, `:R1:`, etc.) is an implementation detail. Don't parse or depend on it. Just use the string as an opaque identifier.
</Callout>

---

## Common Use Cases

### Accessible Form Labels

```tsx
function TextField({ label, type = 'text' }: Props) {
  const id = useId();

  return (
    <div className="field">
      <label htmlFor={id}>{label}</label>
      <input id={id} type={type} />
    </div>
  );
}
```

### ARIA Descriptions

```tsx
function PasswordField() {
  const id = useId();
  const descriptionId = `${id}-description`;

  return (
    <div>
      <label htmlFor={id}>Password</label>
      <input
        id={id}
        type="password"
        aria-describedby={descriptionId}
      />
      <p id={descriptionId}>
        Must be at least 8 characters with one number.
      </p>
    </div>
  );
}
```

### Multiple Related IDs

Use a single `useId` call and derive related IDs:

```tsx
function FormField({ label, hint, error }: Props) {
  const id = useId();
  const hintId = `${id}-hint`;
  const errorId = `${id}-error`;

  // Build aria-describedby from present elements
  const describedBy = [
    hint && hintId,
    error && errorId,
  ].filter(Boolean).join(' ') || undefined;

  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input
        id={id}
        aria-describedby={describedBy}
        aria-invalid={!!error}
      />
      {hint && <p id={hintId} className="hint">{hint}</p>}
      {error && <p id={errorId} className="error">{error}</p>}
    </div>
  );
}
```

### Radio Button Groups

```tsx
function RadioGroup({ name, options, value, onChange }: Props) {
  const groupId = useId();

  return (
    <fieldset>
      <legend>{name}</legend>
      {options.map((option, index) => {
        const optionId = `${groupId}-${index}`;
        return (
          <div key={option.value}>
            <input
              type="radio"
              id={optionId}
              name={name}
              value={option.value}
              checked={value === option.value}
              onChange={() => onChange(option.value)}
            />
            <label htmlFor={optionId}>{option.label}</label>
          </div>
        );
      })}
    </fieldset>
  );
}
```

### Accordion/Disclosure Patterns

```tsx
function Accordion({ items }: { items: AccordionItem[] }) {
  const id = useId();
  const [openIndex, setOpenIndex] = useState<number | null>(null);

  return (
    <div>
      {items.map((item, index) => {
        const headerId = `${id}-header-${index}`;
        const panelId = `${id}-panel-${index}`;
        const isOpen = openIndex === index;

        return (
          <div key={index}>
            <h3>
              <button
                id={headerId}
                aria-expanded={isOpen}
                aria-controls={panelId}
                onClick={() => setOpenIndex(isOpen ? null : index)}
              >
                {item.title}
              </button>
            </h3>
            <div
              id={panelId}
              role="region"
              aria-labelledby={headerId}
              hidden={!isOpen}
            >
              {item.content}
            </div>
          </div>
        );
      })}
    </div>
  );
}
```

---

## When NOT to Use useId

### Don't Use for List Keys

```tsx
// ❌ Wrong: useId for keys
function List({ items }) {
  return items.map(item => {
    const id = useId(); // Called in a loop!
    return <li key={id}>{item.name}</li>;
  });
}

// ✅ Right: Use data IDs for keys
function List({ items }) {
  return items.map(item => (
    <li key={item.id}>{item.name}</li>
  ));
}
```

List keys should come from your data, not `useId`. Keys identify which item changed; `useId` generates DOM IDs.

### Don't Use for CSS Selectors

```tsx
// ❌ Avoid: useId for styling
function Component() {
  const id = useId();
  return <div id={id} className={styles.component}>...</div>;
}
```

Use classes for styling, not IDs. IDs have high specificity and shouldn't be used for CSS.

### Don't Use When You Don't Need IDs

```tsx
// ❌ Unnecessary: No ID relationship needed
function Button({ children }) {
  const id = useId(); // Why?
  return <button id={id}>{children}</button>;
}

// ✅ Just don't use an ID
function Button({ children }) {
  return <button>{children}</button>;
}
```

Only generate IDs when you need to connect elements (labels, ARIA, etc.).

---

## Server Rendering Considerations

### identifierPrefix

When rendering multiple React roots on the same page, use `identifierPrefix` to avoid collisions:

```tsx
// Root 1
hydrateRoot(
  container1,
  <App />,
  { identifierPrefix: 'app1-' }
);

// Root 2
hydrateRoot(
  container2,
  <App />,
  { identifierPrefix: 'app2-' }
);
```

Now IDs will be `:app1-r0:` and `:app2-r0:` instead of both being `:r0:`.

### Server Components

`useId` works in Server Components in React 19:

```tsx
// Server Component
async function ServerForm() {
  const id = useId();

  return (
    <form>
      <label htmlFor={id}>Search</label>
      <input id={id} name="query" />
    </form>
  );
}
```

---

## Building Accessible Components

### Complete Form Input Pattern

```tsx
type InputProps = {
  label: string;
  name: string;
  type?: string;
  required?: boolean;
  hint?: string;
  error?: string;
};

function Input({
  label,
  name,
  type = 'text',
  required,
  hint,
  error,
}: InputProps) {
  const id = useId();
  const hintId = hint ? `${id}-hint` : undefined;
  const errorId = error ? `${id}-error` : undefined;

  const describedBy = [hintId, errorId].filter(Boolean).join(' ') || undefined;

  return (
    <div className="form-field">
      <label htmlFor={id}>
        {label}
        {required && <span aria-hidden="true"> *</span>}
      </label>

      <input
        id={id}
        name={name}
        type={type}
        required={required}
        aria-describedby={describedBy}
        aria-invalid={error ? true : undefined}
      />

      {hint && (
        <p id={hintId} className="hint">
          {hint}
        </p>
      )}

      {error && (
        <p id={errorId} className="error" role="alert">
          {error}
        </p>
      )}
    </div>
  );
}
```

### Tooltip with ARIA

```tsx
function Tooltip({ children, content }: Props) {
  const id = useId();
  const [isVisible, setIsVisible] = useState(false);

  return (
    <div className="tooltip-container">
      <button
        aria-describedby={isVisible ? id : undefined}
        onMouseEnter={() => setIsVisible(true)}
        onMouseLeave={() => setIsVisible(false)}
        onFocus={() => setIsVisible(true)}
        onBlur={() => setIsVisible(false)}
      >
        {children}
      </button>

      {isVisible && (
        <div id={id} role="tooltip" className="tooltip">
          {content}
        </div>
      )}
    </div>
  );
}
```

### Combobox/Autocomplete

```tsx
function Combobox({ label, options, onSelect }: Props) {
  const id = useId();
  const listboxId = `${id}-listbox`;
  const [query, setQuery] = useState('');
  const [isOpen, setIsOpen] = useState(false);
  const [activeIndex, setActiveIndex] = useState(-1);

  const filtered = options.filter(opt =>
    opt.toLowerCase().includes(query.toLowerCase())
  );

  const activeDescendant = activeIndex >= 0
    ? `${id}-option-${activeIndex}`
    : undefined;

  return (
    <div>
      <label htmlFor={id}>{label}</label>
      <input
        id={id}
        role="combobox"
        aria-expanded={isOpen}
        aria-controls={listboxId}
        aria-autocomplete="list"
        aria-activedescendant={activeDescendant}
        value={query}
        onChange={e => setQuery(e.target.value)}
        onFocus={() => setIsOpen(true)}
      />

      {isOpen && filtered.length > 0 && (
        <ul id={listboxId} role="listbox">
          {filtered.map((option, index) => (
            <li
              key={option}
              id={`${id}-option-${index}`}
              role="option"
              aria-selected={index === activeIndex}
              onClick={() => {
                onSelect(option);
                setQuery(option);
                setIsOpen(false);
              }}
            >
              {option}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

---

## Summary

`useId` generates stable, unique IDs for accessibility and DOM relationships:

- **Stable**: Same ID on server and client
- **Unique**: No collisions between component instances
- **Streaming-safe**: Works with React 18+ streaming SSR
- **Tree-based**: IDs derive from component position, not render order

Use it for:
- Form label/input associations (`htmlFor`/`id`)
- ARIA relationships (`aria-describedby`, `aria-labelledby`, `aria-controls`)
- Any DOM ID that connects elements

Don't use it for:
- List keys (use data IDs)
- CSS styling (use classes)
- When you don't need an ID

<HookCard
  name="useId"
  signature="const id = useId()"
  description="Generates a unique, stable ID for accessibility attributes. Works with SSR and streaming. Derive multiple related IDs from a single useId call."
  category="identity"
/>

---

## Exercises

### Warm-up

Create a `Checkbox` component with proper label association:

```tsx
function Checkbox({ label, checked, onChange }) {
  // Add useId for accessibility
}

<Checkbox label="Accept terms" checked={agreed} onChange={setAgreed} />
```

### Core

Build a `Select` component with full ARIA support:

```tsx
type SelectProps = {
  label: string;
  options: { value: string; label: string }[];
  value: string;
  onChange: (value: string) => void;
  error?: string;
};

// Should have:
// - Label connected to select
// - Error message with aria-describedby
// - aria-invalid when error present
```

### Stretch

Create a fully accessible `Tabs` component:

```tsx
type TabsProps = {
  tabs: { id: string; label: string; content: ReactNode }[];
  defaultTab?: string;
};

// Requirements:
// - Proper role="tablist", role="tab", role="tabpanel"
// - aria-selected on active tab
// - aria-controls connecting tabs to panels
// - aria-labelledby connecting panels to tabs
// - Keyboard navigation (arrow keys)
// - All IDs generated with useId
```
